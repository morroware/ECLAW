#!/bin/bash
# Set up the Grafana Arch VM as a TLS reverse proxy for the Pi claw app.
# Run this script ON the Grafana Arch Linux VM (the machine that owns
# port 443 at 66.109.44.77).
#
# What it does:
#   1) Installs nginx + certbot (if not already installed)
#   2) Creates sites-available / sites-enabled directory structure
#   3) Deploys a reverse proxy config for claw.thecastlefuncenter.com
#   4) Requests a Let's Encrypt certificate via certbot
#   5) Prints Pi-side .env changes to apply
set -euo pipefail

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

info()  { echo -e "${BLUE}[INFO]${NC}  $*"; }
ok()    { echo -e "${GREEN}[ OK ]${NC}  $*"; }
warn()  { echo -e "${YELLOW}[WARN]${NC}  $*"; }
die()   { echo -e "${RED}[FAIL]${NC}  $*"; exit 1; }

prompt() {
    local var_name="$1"
    local label="$2"
    local default="${3:-}"
    local value

    if [ -n "$default" ]; then
        read -r -p "$label [$default]: " value
        value="${value:-$default}"
    else
        read -r -p "$label: " value
    fi

    printf -v "$var_name" '%s' "$value"
}

prompt_yes_no() {
    local var_name="$1"
    local label="$2"
    local default="${3:-Y}"
    local answer

    read -r -p "$label [Y/n]: " answer
    answer="${answer:-$default}"
    if [[ "$answer" =~ ^[Yy]$ ]]; then
        printf -v "$var_name" '%s' "yes"
    else
        printf -v "$var_name" '%s' "no"
    fi
}

if [ "$(id -u)" -eq 0 ]; then
    die "Run as a normal user (not root). The script will use sudo when needed."
fi

command -v sudo >/dev/null 2>&1 || die "sudo is required"

cat <<'BANNER'

===============================================
 Remote Claw - Grafana VM TLS Proxy Setup
===============================================

This script configures this Arch Linux VM as the
TLS reverse proxy for the Pi claw app.

Architecture:
  Brownrice (remote VPS) -> manages DNS only
  This VM   (port 443)   -> TLS termination + reverse proxy
  Pi        (LAN:8000)   -> claw app (plain HTTP)

BANNER

# Detect if running on Arch
if command -v pacman >/dev/null 2>&1; then
    PKG_MGR="pacman"
elif command -v apt >/dev/null 2>&1; then
    PKG_MGR="apt"
else
    die "Unsupported package manager. Expected pacman (Arch) or apt (Debian/Ubuntu)."
fi

prompt APP_DOMAIN "Domain for the claw app" "claw.thecastlefuncenter.com"
prompt PI_LAN_IP "Pi's private LAN IP (e.g. 192.168.1.50)"
[ -n "$PI_LAN_IP" ] || die "Pi LAN IP is required"
prompt PI_APP_PORT "Pi app port" "8000"
prompt_yes_no INSTALL_PKGS "Install/update nginx + certbot" "Y"
prompt_yes_no RUN_CERTBOT "Request Let's Encrypt certificate after config deploy" "Y"

# ── 1) Install packages ──────────────────────────────────────────────────────
if [ "$INSTALL_PKGS" = "yes" ]; then
    info "Installing nginx + certbot"
    if [ "$PKG_MGR" = "pacman" ]; then
        sudo pacman -S --needed --noconfirm nginx certbot certbot-nginx
    else
        sudo apt update
        sudo apt install -y nginx certbot python3-certbot-nginx
    fi
    ok "Packages installed"
fi

# ── 2) Set up sites-available / sites-enabled structure ───────────────────────
SITES_AVAILABLE="/etc/nginx/sites-available"
SITES_ENABLED="/etc/nginx/sites-enabled"
NGINX_CONF="/etc/nginx/nginx.conf"

sudo mkdir -p "$SITES_AVAILABLE" "$SITES_ENABLED"

# Check if nginx.conf already includes sites-enabled
if ! sudo grep -q 'include.*sites-enabled' "$NGINX_CONF" 2>/dev/null; then
    info "Adding sites-enabled include to nginx.conf"
    # Insert include directive inside the http {} block
    sudo cp "$NGINX_CONF" "${NGINX_CONF}.bak.$(date +%Y%m%d%H%M%S)"
    if sudo grep -q 'http {' "$NGINX_CONF"; then
        sudo sed -i '/http {/a \    include /etc/nginx/sites-enabled/*;' "$NGINX_CONF"
        ok "Added include directive to nginx.conf"
    else
        warn "Could not find 'http {' block in nginx.conf. Add manually:"
        warn "  include /etc/nginx/sites-enabled/*;"
    fi
fi

# ── 3) Deploy claw proxy config ──────────────────────────────────────────────
CONF_FILE="${SITES_AVAILABLE}/${APP_DOMAIN}"

info "Generating nginx config: $CONF_FILE"
sudo tee "$CONF_FILE" > /dev/null <<NGINX
# Claw TLS reverse proxy — auto-generated by setup_grafana_tls_proxy.sh
# Pi backend: ${PI_LAN_IP}:${PI_APP_PORT}

# Rate & connection limiting
limit_req_zone  \$binary_remote_addr zone=claw_api:10m   rate=10r/s;
limit_req_zone  \$binary_remote_addr zone=claw_join:10m  rate=3r/m;
limit_conn_zone \$binary_remote_addr zone=claw_perip:10m;

server {
    listen 80;
    server_name ${APP_DOMAIN};
    return 301 https://\$host\$request_uri;
}

server {
    listen 443 ssl http2;
    server_name ${APP_DOMAIN};
    server_tokens off;
    client_max_body_size 1m;

    limit_conn claw_perip 30;

    # Certs — certbot will fill these in
    ssl_certificate /etc/letsencrypt/live/${APP_DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${APP_DOMAIN}/privkey.pem;

    # TLS hardening
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:claw_ssl:10m;
    ssl_session_timeout 1d;
    ssl_stapling on;
    ssl_stapling_verify on;

    # Security headers
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains" always;
    add_header X-Frame-Options DENY always;
    add_header X-Content-Type-Options nosniff always;
    add_header Referrer-Policy strict-origin-when-cross-origin always;
    add_header Content-Security-Policy "default-src 'self'; connect-src 'self' wss: ws:; img-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'self'" always;
    add_header Permissions-Policy "camera=(), microphone=(), geolocation=()" always;

    # WebSocket timeout (24h)
    proxy_read_timeout 86400;
    proxy_send_timeout 86400;

    # -- App: static frontend + general catch-all --
    location / {
        proxy_pass http://${PI_LAN_IP}:${PI_APP_PORT};
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
    }

    # -- API: general rate limit --
    location /api/ {
        limit_req zone=claw_api burst=20 nodelay;
        proxy_pass http://${PI_LAN_IP}:${PI_APP_PORT};
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
    }

    # -- Queue join: strict rate limit --
    location = /api/queue/join {
        limit_req zone=claw_join burst=2 nodelay;
        proxy_pass http://${PI_LAN_IP}:${PI_APP_PORT};
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
    }

    # -- WebSocket: status broadcast --
    location /ws/status {
        proxy_pass http://${PI_LAN_IP}:${PI_APP_PORT};
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_buffering off;
        proxy_read_timeout 86400;
    }

    # -- WebSocket: player control --
    location /ws/control {
        proxy_pass http://${PI_LAN_IP}:${PI_APP_PORT};
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_buffering off;
        proxy_read_timeout 86400;
    }

    # -- MediaMTX WebRTC (WHEP signaling) --
    # Route through FastAPI's built-in stream proxy (stream_proxy.py)
    # which forwards to MediaMTX on localhost:8889.  We cannot hit
    # MediaMTX directly because it binds to 127.0.0.1.
    location /stream/ {
        proxy_pass http://${PI_LAN_IP}:${PI_APP_PORT};
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_read_timeout 86400;
    }

    # -- Admin: LAN only --
    location /admin/ {
        allow 192.168.0.0/16;
        allow 10.0.0.0/8;
        allow 172.16.0.0/12;
        allow 127.0.0.0/8;
        deny all;
        proxy_pass http://${PI_LAN_IP}:${PI_APP_PORT};
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    }
}
NGINX
ok "Nginx config written to $CONF_FILE"

# Enable the site
sudo ln -sf "$CONF_FILE" "${SITES_ENABLED}/${APP_DOMAIN}"
ok "Symlinked to sites-enabled"

# Test config
info "Testing nginx configuration"
sudo nginx -t || die "nginx config test failed — check the config file"
ok "nginx config OK"

# ── 4) Certbot ────────────────────────────────────────────────────────────────
if [ "$RUN_CERTBOT" = "yes" ]; then
    info "Requesting Let's Encrypt certificate for ${APP_DOMAIN}"
    echo ""
    warn "Make sure BEFORE continuing:"
    warn "  1. DNS A record for ${APP_DOMAIN} points to 66.109.44.77"
    warn "  2. Port 80 on this machine is reachable from the internet"
    echo ""
    read -r -p "Ready? Press Enter to continue (Ctrl+C to abort)..."

    sudo certbot --nginx -d "${APP_DOMAIN}"
    ok "Certificate issued"
else
    warn "Skipped certbot. Run manually when DNS is ready:"
    warn "  sudo certbot --nginx -d ${APP_DOMAIN}"
fi

# ── 5) Start / reload nginx ──────────────────────────────────────────────────
info "Reloading nginx"
sudo systemctl enable nginx
sudo systemctl reload nginx || sudo systemctl start nginx
ok "nginx reloaded"

# ── 6) Detect this VM's LAN IP for Pi config ─────────────────────────────────
VM_LAN_IP="$(ip -4 route get 1 2>/dev/null | awk '{print $7; exit}' || echo 'UNKNOWN')"

cat <<EOF

${BOLD}========================================${NC}
${GREEN}Grafana VM TLS proxy is configured!${NC}
${BOLD}========================================${NC}

${BOLD}Now apply these changes on the Pi:${NC}

  1. Edit /opt/claw/.env:

     CORS_ALLOWED_ORIGINS=https://${APP_DOMAIN}
     TRUSTED_PROXIES=127.0.0.1/32,::1/128,${VM_LAN_IP}/32

  2. Restart the Pi app:

     sudo systemctl restart claw-server

  3. Forward WebRTC UDP port on your router:

     The video stream uses WebRTC which requires a direct UDP path
     from browsers to MediaMTX on the Pi (port 8189).
     Add a port-forward rule on your router:

       UDP 8189  →  <Pi LAN IP>:8189

     Also allow it through the Pi firewall:

       sudo ufw allow 8189/udp

  4. (Optional) Lock down Pi firewall:

     sudo ufw allow from ${VM_LAN_IP} to any port ${PI_APP_PORT} proto tcp
     sudo ufw deny ${PI_APP_PORT}/tcp

  5. Test from any browser:

     https://${APP_DOMAIN}
     https://${APP_DOMAIN}/api/health

EOF
